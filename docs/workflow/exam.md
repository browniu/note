# 热点速览

## 原型链
JS就是基于原型的语言。每个对象都有一个原型，对象以原型为模板、从原型继承方法和属性。原型也有自己的原型，一层一层、以此类推。这种关系常被称为
原型链。
> 查找对象属性的路径：自身》原型》父级原型》祖父级原型》顶层原型

## 继承

### 原型赋值继承
将父类的实例直接赋值给子类的原型，子实例通过原型链式查找可以继承父类的属性
* 缺点是继承的方向是单向的，无法向父类的方法传参/处在原型链中的所有属性都是共享可见的

### 构造函数继承
子类在其构造函数中用实例的this通过`call/apply`调用父类的构造函数，子实例就可以访问父类的属性
* 优点是1.可以一对多继承，不是链式的2.弥补了原型链继承的缺点：子实例可以向父类构造传参/父类原型属性不可见
* 缺点也是只继承父类构造函数的属性，无法继承父类原型属性
* 还有无法实现构造函数的复用/每个新的子实例都有父类构造函数的副本，数据臃肿

### 分离组合继承（寄生）
构造函数属性继承和建立子类和父类原型的链接，分离就是分两步走；组合是指同时继承子类构造函数和原型中的属性
* 这里用到了Object.creat(obj)方法，该方法会对传入的obj对象进行浅拷贝。将父类原型复制给了子类原型。
* 优点是在子类构造函数中继承了父类的属性/子类原型和父类原型建立了连接

### ES6继承
es6引入了class、extends、super、static实现继承

## 跨域
域的限制：JavaScript/浏览器环境出于安全方面的考虑，不允许跨域名/端口/协议调用其他页面的对象。

### JSONP
利用 `<script>` 元素的开放策略，可以不受域的限制从其他获取 JSON 数据。
* 优点 步骤简单/兼容性好
* 缺点 只支持GET方式/无法返回状态码/被劫持的风险高

### CORS跨资源共享策略
服务器允许，浏览器支持即可
* Access-Control-Allow-Origin：表示服务端允许的请求源，*标识任何外域，多个源 , 分隔

### NGINX反向代理
开发环境配置，且步骤稍复杂
* 通过nginx配置代理服务器（域名与test1相同，端口不同）做跳板机，反向代理访问test2接口，且可以修改cookie中test信息，方便当前域cookie写入，实现跨域登录。

### iframe类
* location.hash 父页面通过改变`src`的`hash`值可以跨域向子页面传递数据
* window.name 子页面设置该值后修改`src`为同源页面后可获取该值
* postMessage 可以进行不受域限制的父子通信

### webscoket
* 允许跨域的双向通信协议

## URL编码
* `encodeURI` 编码整条URL（!#$&'(),;=?~）不编码
* `encodeURIComponent` 编码某一段URL （!'()*-._~）不编码

## 闭包
闭包的实质是因为函数嵌套而形成的作用域。即函数A内部有一个函数B，函数B可以访问A中的变量，B就是一个闭包。
* 私有变量
* 回调函数

## BFC
`positon:absolute/fixed` / `display:inline-block/table` / `float:left/right` / `overflow!=visiblle`

## 网页渲染的流程
* 输入网址
* DNS服务器解析IP
* 建立TCP链接
* 浏览器发送HTTP请求
* 服务器返回资源
* 浏览器载入并解析资源
* 渲染DOM-Tree/CSS-Tree/组合Render-Tree/渲染

## 纯函数
如果函数的调用参数完全相同，则永远返回相同的结果。它不依赖程序执行期间的函数外部的任何状态，不产生任何可观察的副作用（状态交互），便于测试和重构。

## TCP
### 三次握手
客户端与服务器建立建立TCP链接时的通信协议
* 客户端发送`SYN`请求（能听到我说话吗？）
* 服务器收到`SYN`请求包，确认后发出自身的`SYN+ACK`请求包（听到了，你能听到我说话吗？）
* 客户端收到`SYN+ACK`请求包，确认后发出`ACK`包，进入链接状态（好的，那我们开始聊天吧）

### 四次挥手
客户端与服务器断开TCP链接时的操作
* 客户端发送一个请求断开的包（我挂了）
* 服务端返回一个同意断开的包（好的）
* 服务端发送一个请求断开的包（我也挂了）
* 客户端发送一个确认断开的包（好的）

## 深拷贝
深拷贝是指源对象和拷贝对象相互独立，其中任何一个发生变化都不会对对方产生影响。深浅拷贝最根本的区别就是是否真正获取到一个对象的复制实体，而不是引用。深拷贝在内存中新建了复制体的存储，而浅拷贝只是引用了源头的内存地址。
* 使用JSON `b=JSON.parse(JSON.sringify(a))` 
* 递归遍历属性

## 数据类型
* 基本：`undefined` `null` `string` `number` `boolean`
* 引用：`object` `array` `function`

## diff
1. 比较文本差异的算法
    * 比较两个树形数据结构的差异时，传统diff算法是循环递归每一个节点，复杂度达到O(n^3)
    * 三大策略：1忽略跨级操作只进行同层级比较 2拥有相同类的组件生成相似树形结构，不同类组件生成不同树形结构 3同级别子节点通过唯一id区分
2. 比较粒度：
    * Tree: 树的每一层都会比较
    * component：同类继续比较，不同类直接替换
    * Element：完全遍历，根据ID确定要移除和新增的元素（）
    * 文本类型变换直接替换不会diff
3. 基于diff的优化：
    * 减少DOM的操作，使用隐藏而不是移除
    * 使用生命周期` shouldComponentUpdate()`减少不必要的更新
    * 类似的结构封装成组件
    * 列表元素key值最好不要设置为数组的index，因为即使元素没变但是index可能会变

## 机器学习模型建立
* 模型就是一个带有可训练参数的函数。这个函数表达了输入和输出之间的变换关系。我们通过在数据集上训练模型来获得最佳参数。训练好的模型可以精确的
将输入数据转换为我们想得到的输出。
* 最常见的模型是Sequential模型。Sequential模型将网络的每一层简单的叠在一起。您可以将需要的层按顺序写在一个列表里。
* 输入层规定输入数据的格式，输出层规定输出数据的格式，中间的神经网络网络层负责训练参数

## 内存泄露
* Chrome的 可以进行内存占用的监控 timeline 和 profiles。
* 通过触发某些事件进行泄漏点的定位

## this
调用上下文（invocation context），函数的每一次调用都会包含一个`this`对象。它是指向对象的关键字。
* 默认绑定/普通函数调用 `this`指向全局对象（window）
* 隐式绑定/函数作为对象属性调用 `this`指向该对象
* 强制绑定/使用函数的方法`apply()`、`apply()`、`apply()`可以明确指定`this`的绑定目标
* 构造绑定/使用`new`调用构造函数创建实例，`this`指向这个实例对象

## 函数式编程
允许把函数当作一个实参或返回值，将复杂的计算分解成一些列嵌套的函数，逐层推导，不断渐进。
* 代码结构易读性/逻辑清晰
* 高阶函数/函数作为实参，返回一个新函数
* 柯里化/将一个完整的运算过程分解成多个函数调用 参数复用/提前判断/延迟触发

## 模块化
高内聚-低耦合
不同功能模块之间的依赖关系应该简单清晰，也就是保持模块之间的低耦合性；一个模块应该把自己的功能封装好，让外界不要太依赖于自己内部的状态，这样不会因为内部的变化而影响外部模块的功能，也就是高内聚性

## Promise
为了解决异步编程时出现回调多层嵌套的问题。提高代码的可读性和可维护性。
* 原理：Promise也还是使用回调函数，只不过是把回调封装在了内部，我们使用上一直通过then方法的链式调用，使得多层的回调嵌套看起来变成了同一层的，书写上以及理解上会更直观和简洁一些。
* 三个状态 `pending` `resolved` `rejected`
* 参数是一个函数，函数的两个参数是两个函数 `resolve` `reject` 用与状态转换
* 实例方法`then` 可以进行链式调用，获取上一步返回的结果
* 实例方法`reject` 可以捕获`then`中的异常
* `Promise.all` 用于封装多个Promise对象

##  async/await
ES7提出的关于异步操作的终极方案。相较于其他异步方案 `async` 流程清晰，直观、语义更加明显。它使得操作异步操作流程就如同操作同步流程。同时 async 函数自带执行器，执行的时候无需手动加载。
* 返回一个`Promise`对象
* `async` 会等待所有的`await`执行完`Promise`
* 其中一个`await` 抛异常会中断后续操作，可以通过`try/catch`解决

## web安全
* XSS漏洞：跨站脚本攻击/注入恶意可执行脚本-不要直接从DOM直接获取数据/不要使用可解析字符串脚本的方法/做escape转译编码
* CSRF：跨站请求攻击/身份模拟发送服务器请求-正确使用GET/POST请求/非GET请求中携带token
* SQL注入：服务器未过滤用户输入，执行了攻击者发送的SQL查询代码

## ES6典型的新特性
* ES6其实包含ES2015/ES2016/ES2017/ES2018等
* let和const/模版字符串/箭头函数/symbol/Set/Map类型/for of 遍历/Promise/Async/Class/解构赋值/展开运算符等

## 事件模型
* DOM0级模型：事件不会传播，没有事件流
* DOM2级模型：捕获阶段-自上而下/冒泡阶段-自下而上/处理阶段-到达目标元素的监听函数

## 浏览器兼容性
* 样式兼容性 默认状态-clear.css/CSS3属性-前缀
* 交互兼容性 事件监听-封装函数/滚动高度
* 浏览器hack 判断浏览器类型的一些方法

## AJAX 异步请求数据
* 不刷新页面的情况下，Ajax通过异步请求加载后台数据，并在页面上渲染。
* 使用核心对象 `XMLHttpRequest`的 `open` 'send'方法建立请求
* `responseXML`& `responseText` 响应请求结果
* 使用`Fetch`替换：逻辑清晰/基于Promise 支持async-await

## 垂直居中
* line-height = height
* display: inline-block & vertical-align: middle & ::after并列一个高度100%的伪元素
* display:table-cell;vertical-align:middle;
* display: flex;align-items: center;
* transform & top
* padding:15px 0

## 浏览器的构成部分
* 用户界面：地址栏/前后按钮/书签目录等
* 浏览器引擎：查询/操作渲染引擎接口
* 渲染引擎：现实请求的内容/解析html和css
* 网络：完成网络调用
* JS解释器：执行JS代码
* 数据存储

## REM布局
*  设置html元素的font-size和屏幕宽度成正比 rem单位所代表的实际尺寸就和屏幕宽度成正比
*  像素尺寸与设备尺寸并不是1：1的对应关系，而是取决于像素密度。比如设备尺寸同为350，有的是三倍屏，像素尺寸就是1125,两倍屏就是750,使用REM布局
可以使我们只需要按照设计稿写页面，页面在其他设备尺寸上可以自适应的缩放显示，保持高度的设计稿还原。
* 正比可以通过媒介查询/JS定义/vw来实现
* 优点是灵活/还原度高
* JS与CSS具有一定的耦合性/不适合多端适配项目

## 适配方案
* 百分比布局-计算困难
* 媒介查询-多套样式-繁琐
* rem布局-灵活
* vw/vh-兼容性问题

## CDN-内容分发网络
* 是节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络
* 实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上
* 尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定

## Gzip
* HTTP协议上的gzip编码是一种用来改进web应用程序性能的编码协议
* 压缩比率在3到10倍左右，可以大大节省服务器的网络带宽

## 阻塞


## 前端框架比较
### 共相同
* 都采用性能更高的虚拟Dom
* 都支持响应式和组件化
* 都主要维护核心库，将其他功能如状态管理/路由等交给配套组件完成
### 差异点
* 数据流 React是MVC单向数据流，Vue是MVVM双向数据流
* React兼容性更好，支持IE8
* React具有更加强大的社区生态
* React对TS支持更高
* Vue的组件优化更容易，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。
* vue更接近传统的前端开发方式，模版/样式/逻辑代码结构更清晰，React主张用jsx表示一切，这赋予了React更高的灵活性，但是在某些情况下代码可读性不如Vue。
* vue中的样式设置更加灵活，scope实现起来更加简便
* Vue的指令更加丰富，使用成本更低，但是增加了学习成本
* React具备更加完善的原生渲染能力和更好的生态支持
* 两者相互借鉴，互相补充。如Mobx 实际上使用体验更接近vue，vue也可以支持jsx语法等等方面可以体现

## 常用状态码
* 200 请求成功
* 300 重定向，当客户端的请求引起了资源URI的变化时发送此状态码
* 404 请求资源不存在
* 500 服务器内部错误

## 优化首屏加载
* 将公用的JS库通过`<script>`标签进行CDN引入，减小bundleJS的体积
* 分包加载/懒加载/闲时加载/预加载
* 提供Loading界面提升用户体验
  
## 优化网站性能
* 减少HTTP请求数量
* 闲时加载
* WEBP图片压缩方案
* 优化资源加载顺序
* 减少重排性操作
* 避免DOM操作


## React

### 组件控制
* 受控组件：react 通过在表单元素上绑定value值，通过 onchange处理函数 setState 的方式控制表单元素的value
* 非受控组件：表单组件自己保存value状态，react通过ref获取节点，来进行value的控制

### 无状态组件
无状态组件就是一个单纯的render函数
* 通过减少继承Component而来的生命周期函数而达到性能优化的效果。
* 因为没有shouldComponentUpdate生命周期函数，所以每次state更新，它都会重新绘制render函数。

### 高阶组件
* 高阶组件是参数为组件，返回值为新组件的函数，是 React 中用于复用组件逻辑的一种设计模式
* 装饰器是高阶组件的一种应用方式

### ReactDiff
* 把树形结构按照层级分解，只比较同级元素。
* 通过给列表结构的每个单元添加的`Key`值进行区分同层次的子节点的比较。
* React 只匹配相同名称的`Component`
* 合并操作，调用`setState`方法的时候, React为其添加`dirty`标记，每一个循环结束React会检查所有标记`dirty`的组件进行重新绘制。
* 可以重写 shouldComponentUpdate 提高 diff 的性能。

### 异步`setState`
* 保持内部的一致性，因为props只有在父级渲染完成后才能拿到，无法同步更新。
* 性能优化，不阻塞当前操作
* 异步可以后台更新

### 工程模版优化
* Px2REM 移动端适配/提高设计稿还原度
* WebP 图片格式转换 优化资源大小/提交页面加载速度
* Tracker 埋点自动化处理/提高开发效率
* JSONP 请求的拦截，上报发送参数和接收数据/便于移动端调试
* 禁用橡皮筋 移动端适配全屏应用或不出现滚动条时禁用橡皮筋效果
* travisCI 持续集成化部署

## Vue

### 双向绑定/响应式
Vue通过数据劫持结合发布订阅模式来实现双向绑定的。当一个Vue实例被创建时，vue会遍历data选项的属性，用Object.defineProperty将他们转为getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。


### MVVM
MVVM包含三个部分Model、View、ViewModel。
* Model代表数据模型，定义数据和业务逻辑
* View代表视图，负责数据UI展示
* ViewModel作为中间层负责监听Model中的数据改变然后控制View的更新

## 书籍推荐

### HTML与CSS进阶指南

这本书对前端知识点的讲解深入浅出，读的时候经常有茅塞顿开的感觉。特别是刚入门的那个阶段，很多困扰和很长时间的纠结点都一扫而空，读完感觉自己就没那么菜了。

### JavaScript高级程序设计

这本书可以说是前端领域的必读书目了吧。但是我建议不要从头到位那样读，因为知识点都比较深，从头到尾看一遍会非常痛苦。可以把它当成工具书，当项目经验积累到一定程度在去看那那些拿不稳的点。

### 你不知道的JavaScript

这套书看了好久，到现在还没看完。以前经常听人说JS是一种很简单的弱类型脚本语言/玩具语言。但是读这套书的时候我觉得JS一点也不简单，而且越来越觉得JS是世界上最好的语言，集大成之作。

### 黑客与画家

这是一本非常有趣的书，里面有很多观点很奇怪，但是非常符合我的口味。例如我喜欢编程的同时也非常喜欢画画，而这本书的作者也告诉我，编程和画画没有本质上的区别。

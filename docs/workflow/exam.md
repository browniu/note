# 热点速览

## 原型链
* JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。
* 定义一个a(),new a() 生成 b()，b() 的 __proto__ 属性就是a.prototype. 当访问 b() 的一个属性, 浏览器首先查找 b() 是否有这个属性. 如果 b() 没有这个属性, 然后浏览器就会在 b() 的 __proto__ 中查找这个属性(也就是 a.prototype). 如果 b() 的 __proto__ 有这个属性, 那么 b() 的 __proto__ 上的这个属性就会被使用. 否则, 浏览器就会去查找 b() 的 __proto__ 的 __proto__ ，看它是否有这个属性. 默认情况下, 所有函数的原型链的顶端 就是 window.Object.prototype. 如果它的上面都不存在这个属性，然后就得出这个属性是 undefined.

## 继承
顾名思义，继承首先需要有父类
### 原型链继承
实例B的原型等于实例A
* 实例C可继承的构造B、构造A、原型A的属性
* 继承单向/属性共享
### 构造函数继承
用`call/apply`将父类构造函数引入子类（在子类函数中做了父类函数的自执行）
* 只继承父类构造函数的属性，无法继承父类原型属性
* 弥补了原型链继承的一些缺点
* 可以一对多的继承（`call`多个父类）
* 子实例可以向父实例传参
* 无法实现构造函数的复用/每个新的子实例都有父类构造函数的副本，数据臃肿

## 跨域
域的限制：JavaScript/浏览器环境出于安全方面的考虑，不允许跨域名/端口调用其他页面的对象。

### JSONP
利用 `<script>` 元素的开放策略，可以不受域的限制从其他获取 JSON 数据。
* 优点 步骤简单/兼容性好
* 缺点 只支持GET方式/无法返回状态码/被劫持的风险高

### CORS
服务器允许，浏览器支持即可

### 反向代理
开发环境配置，且步骤稍复杂

## URL编码
* `encodeURI` 编码整条URL（!#$&'(),;=?~）不编码
* `encodeURIComponent` 编码某一段URL （!'()*-._~）不编码

## 闭包
闭包的实质是因为函数嵌套而形成的作用域。即函数A内部有一个函数B，函数B可以访问A中的变量，B就是一个闭包。

## BFC
`positon:absolute/fixed` / `display:inline-block/table` / `float:left/right` / `overflow!=visiblle`

## 网页渲染的流程
* 输入网址
* DNS服务器解析IP
* 建立TCP链接
* 浏览器发送HTTP请求
* 服务器返回资源
* 浏览器载入并解析资源
* 渲染DOM树/CSSOM/运行JS

## 纯函数
如果函数的调用参数完全相同，则永远返回相同的结果。它不依赖程序执行期间的函数外部的任何状态，不产生任何可观察的副作用（状态交互），便于测试和重构。

## TCP
### 三次握手
客户端与服务器建立建立TCP链接时的通信协议
* 客户端发送`SYN`请求（能听到我说话吗？）
* 服务器收到`SYN`请求包，确认后发出自身的`SYN+ACK`请求包（听到了，你能听到我说话吗？）
* 客户端收到`SYN+ACK`请求包，确认后发出`ACK`包，进入链接状态（好的，那我们开始聊天吧）

### 四次挥手
客户端与服务器断开TCP链接时的操作
* 客户端发送一个请求断开的包（我挂了）
* 服务端返回一个同意断开的包（好的）
* 服务端发送一个请求断开的包（我也挂了）
* 客户端发送一个确认断开的包（好的）

## 深拷贝
深拷贝是指源对象和拷贝对象相互独立，其中任何一个发生变化都不会对对方产生影响。深浅拷贝最根本的区别就是是否真正获取到一个对象的复制实体，而不是引用。深拷贝在内存中新建了复制体的存储，而浅拷贝只是引用了源头的内存地址。
* 使用JSON `b=JSON.parse(JSON.sringify(a))` 
* 递归遍历属性

## 数据类型
* 基本：`undefined` `null` `string` `number` `boolean`
* 引用：`object` `array` `function`

## diff
比较文本差异的算法
* 比较两个树形数据结构的差异时，传统diff算法是循环递归每一个节点，复杂度达到O(n^3)
* React/Vue 只进行同层级比较，忽略跨级操作，将复杂度降低为O(n)。开发过程中列表渲染时设置的key值就是分配给同一层级的一组子节点，作为唯一id进行区分

## 前端框架比较
### 共相同
* 都采用性能更高的虚拟Dom
* 都支持响应式和组件化
* 都主要维护核心库，将其他功能如状态管理/路由等交给配套组件完成
### 差异点
* 数据流 React是MVC单向数据流，Vue是MVVM双向数据流
* React兼容性更好，支持IE8
* React具有更加强大的社区生态
* React对TS支持更高
* Vue的组件优化更容易，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。
* vue更接近传统的前端开发方式，模版/样式/逻辑代码结构更清晰，React主张用jsx表示一切，这赋予了React更高的灵活性，但是在某些情况下代码可读性不如Vue。
* vue中的样式设置更加灵活，scope实现起来更加简便
* Vue的指令更加丰富，使用成本更低，但是增加了学习成本
* React具备更加完善的原生渲染能力和更好的生态支持
* 两者相互借鉴，互相补充。如Mobx 实际上使用体验更接近vue，vue也可以支持jsx语法等等方面可以体现

## 常用状态码
* 200 请求成功
* 300 重定向，当客户端的请求引起了资源URI的变化时发送此状态码
* 404 请求资源不存在
* 500 服务器内部错误

## 优化首屏加载
* 将公用的JS库通过`<script>`标签进行CDN引入，减小bundleJS的体积
* 分包加载/懒加载/闲时加载/预加载
* 提供Loading界面提升用户体验
  
## 优化网站性能
* 减少HTTP请求数量
* 闲时加载
* WEBP图片压缩方案
* 优化资源加载顺序
* 减少重排性操作
* 避免DOM操作


## React

### 组件控制
* 受控组件：react 通过在表单元素上绑定value值，通过 onchange处理函数 setState 的方式控制表单元素的value
* 非受控组件：表单组件自己保存value状态，react通过ref获取节点，来进行value的控制

### 无状态组件
无状态组件就是一个单纯的render函数
* 通过减少继承Component而来的生命周期函数而达到性能优化的效果。
* 因为没有shouldComponentUpdate生命周期函数，所以每次state更新，它都会重新绘制render函数。

### 高阶组件
* 高阶组件是参数为组件，返回值为新组件的函数，是 React 中用于复用组件逻辑的一种设计模式
* 装饰器是高阶组件的一种应用方式

### ReactDiff
* 把树形结构按照层级分解，只比较同级元素。
* 通过给列表结构的每个单元添加的`Key`值进行区分同层次的子节点的比较。
* React 只匹配相同名称的`Component`
* 合并操作，调用`setState`方法的时候, React为其添加`dirty`标记，每一个循环结束React会检查所有标记`dirty`的组件进行重新绘制。
* 可以重写 shouldComponentUpdate 提高 diff 的性能。

### 异步`setState`
* 保持内部的一致性，因为props只有在父级渲染完成后才能拿到，无法同步更新。
* 性能优化，不阻塞当前操作
* 异步可以后台更新

### 工程模版优化
* Px2REM 移动端适配/提高设计稿还原度
* WebP 图片格式转换 优化资源大小/提交页面加载速度
* Tracker 埋点自动化处理/提高开发效率

## Vue

### 双向绑定/响应式
Vue通过数据劫持结合发布订阅模式来实现双向绑定的。当一个Vue实例被创建时，vue会遍历data选项的属性，用Object.defineProperty将他们转为getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。

### MVVM
MVVM包含三个部分Model、View、ViewModel。
* Model代表数据模型，定义数据和业务逻辑
* View代表视图，负责数据UI展示
* ViewModel作为中间层负责监听Model中的数据改变然后控制View的更新

## 书籍推荐

### HTML与CSS进阶指南

这本书对前端知识点的讲解深入浅出，读的时候经常有茅塞顿开的感觉。特别是刚入门的那个阶段，很多困扰和很长时间的纠结点都一扫而空，读完感觉自己就没那么菜了。

### JavaScript高级程序设计

这本书可以说是前端领域的必读书目了吧。但是我建议不要从头到位那样读，因为知识点都比较深，从头到尾看一遍会非常痛苦。可以把它当成工具书，当项目经验积累到一定程度在去看那那些拿不稳的点。

### 你不知道的JavaScript

这套书看了好久，到现在还没看完。以前经常听人说JS是一种很简单的弱类型脚本语言/玩具语言。但是读这套书的时候我觉得JS一点也不简单，而且越来越觉得JS是世界上最好的语言，集大成之作。

### 黑客与画家

这是一本非常有趣的书，里面有很多观点很奇怪，但是非常符合我的口味。例如我喜欢编程的同时也非常喜欢画画，而这本书的作者也告诉我，编程和画画没有本质上的区别。

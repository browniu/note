(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{199:function(a,t,r){"use strict";r.r(t);var e=r(0),v=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"热点速览"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#热点速览","aria-hidden":"true"}},[a._v("#")]),a._v(" 热点速览")]),a._v(" "),r("h2",{attrs:{id:"基础"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基础","aria-hidden":"true"}},[a._v("#")]),a._v(" 基础")]),a._v(" "),r("h3",{attrs:{id:"原型链"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原型链","aria-hidden":"true"}},[a._v("#")]),a._v(" 原型链")]),a._v(" "),r("ul",[r("li",[a._v("JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。")]),a._v(" "),r("li",[a._v("定义一个a(),new a() 生成 b()，b() 的 "),r("strong",[a._v("proto")]),a._v(" 属性就是a.prototype. 当访问 b() 的一个属性, 浏览器首先查找 b() 是否有这个属性. 如果 b() 没有这个属性, 然后浏览器就会在 b() 的 "),r("strong",[a._v("proto")]),a._v(" 中查找这个属性(也就是 a.prototype). 如果 b() 的 "),r("strong",[a._v("proto")]),a._v(" 有这个属性, 那么 b() 的 "),r("strong",[a._v("proto")]),a._v(" 上的这个属性就会被使用. 否则, 浏览器就会去查找 b() 的 "),r("strong",[a._v("proto")]),a._v(" 的 "),r("strong",[a._v("proto")]),a._v(" ，看它是否有这个属性. 默认情况下, 所有函数的原型链的顶端 就是 window.Object.prototype. 如果它的上面都不存在这个属性，然后就得出这个属性是 undefined.")])]),a._v(" "),r("h3",{attrs:{id:"继承"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#继承","aria-hidden":"true"}},[a._v("#")]),a._v(" 继承")]),a._v(" "),r("p",[a._v("顾名思义，继承首先需要有父类")]),a._v(" "),r("h4",{attrs:{id:"原型链继承"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原型链继承","aria-hidden":"true"}},[a._v("#")]),a._v(" 原型链继承")]),a._v(" "),r("p",[a._v("实例B的原型等于实例A")]),a._v(" "),r("ul",[r("li",[a._v("实例C可继承的构造B、构造A、原型A的属性")]),a._v(" "),r("li",[a._v("继承单向/属性共享")])]),a._v(" "),r("h4",{attrs:{id:"构造函数继承"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#构造函数继承","aria-hidden":"true"}},[a._v("#")]),a._v(" 构造函数继承")]),a._v(" "),r("h3",{attrs:{id:"跨域"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#跨域","aria-hidden":"true"}},[a._v("#")]),a._v(" 跨域")]),a._v(" "),r("p",[a._v("域的限制：JavaScript/浏览器环境出于安全方面的考虑，不允许跨域名/端口调用其他页面的对象。")]),a._v(" "),r("h4",{attrs:{id:"jsonp"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jsonp","aria-hidden":"true"}},[a._v("#")]),a._v(" JSONP")]),a._v(" "),r("p",[a._v("利用 "),r("code",[a._v("<script>")]),a._v(" 元素的开放策略，可以不受域的限制从其他获取 JSON 数据。")]),a._v(" "),r("h5",{attrs:{id:"优点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点","aria-hidden":"true"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),r("ul",[r("li",[a._v("步骤简单")]),a._v(" "),r("li",[a._v("兼容性好")]),a._v(" "),r("li",[a._v("符合视图层与逻辑层分离的思想")])]),a._v(" "),r("h5",{attrs:{id:"缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点","aria-hidden":"true"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),r("ul",[r("li",[a._v("只支持GET方式")]),a._v(" "),r("li",[a._v("失败时无法返回状态码")]),a._v(" "),r("li",[a._v("被劫持的风险高")])]),a._v(" "),r("h4",{attrs:{id:"cors"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cors","aria-hidden":"true"}},[a._v("#")]),a._v(" CORS")]),a._v(" "),r("p",[a._v("服务器允许，浏览器支持即可")]),a._v(" "),r("h4",{attrs:{id:"反向代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#反向代理","aria-hidden":"true"}},[a._v("#")]),a._v(" 反向代理")]),a._v(" "),r("p",[a._v("开发环境配置，且步骤稍复杂")]),a._v(" "),r("h3",{attrs:{id:"url编码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#url编码","aria-hidden":"true"}},[a._v("#")]),a._v(" URL编码")]),a._v(" "),r("ul",[r("li",[r("code",[a._v("encodeURI")]),a._v(" 编码整条URL（!#$&'(),;=?~）不编码")]),a._v(" "),r("li",[r("code",[a._v("encodeURIComponent")]),a._v(" 编码某一段URL （!'()*-._~）不编码")])]),a._v(" "),r("h2",{attrs:{id:"框架"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#框架","aria-hidden":"true"}},[a._v("#")]),a._v(" 框架")]),a._v(" "),r("h3",{attrs:{id:"react"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react","aria-hidden":"true"}},[a._v("#")]),a._v(" React")]),a._v(" "),r("h4",{attrs:{id:"表单控制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#表单控制","aria-hidden":"true"}},[a._v("#")]),a._v(" 表单控制")]),a._v(" "),r("ul",[r("li",[a._v("受控组件：react 通过在表单元素上绑定value值，通过 onchange处理函数 setState 的方式控制表单元素的value")]),a._v(" "),r("li",[a._v("非受控组件：表单组件自己保存value状态，react通过ref获取节点，来进行value的控制")])]),a._v(" "),r("h4",{attrs:{id:"无状态组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#无状态组件","aria-hidden":"true"}},[a._v("#")]),a._v(" 无状态组件")]),a._v(" "),r("p",[a._v("无状态组件就是一个单纯的render函数")]),a._v(" "),r("ul",[r("li",[a._v("通过减少继承Component而来的生命周期函数而达到性能优化的效果。")]),a._v(" "),r("li",[a._v("因为没有shouldComponentUpdate生命周期函数，所以每次state更新，它都会重新绘制render函数。")])]),a._v(" "),r("h4",{attrs:{id:"diff"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#diff","aria-hidden":"true"}},[a._v("#")]),a._v(" diff")]),a._v(" "),r("p",[a._v("diff：命令比较文本文件")]),a._v(" "),r("ul",[r("li",[a._v("比较两个树形数据结构的差异，传统diff算法是循环递归每一个节点，复杂度达到O(n^3)")]),a._v(" "),r("li",[a._v("React/Vue 只进行同层级比较，忽略跨级操作，将复杂度降低为O(n)。开发过程中列表渲染时设置的key值就是分配给同一层级的一组子节点，作为唯一id进行区分")])]),a._v(" "),r("h4",{attrs:{id:"高阶组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件","aria-hidden":"true"}},[a._v("#")]),a._v(" 高阶组件")]),a._v(" "),r("ul",[r("li",[a._v("高阶组件是参数为组件，返回值为新组件的函数，是 React 中用于复用组件逻辑的一种设计模式")]),a._v(" "),r("li",[a._v("装饰器是高阶组件的一种应用方式")])]),a._v(" "),r("h4",{attrs:{id:"vue-对比-react"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-对比-react","aria-hidden":"true"}},[a._v("#")]),a._v(" Vue 对比 React")]),a._v(" "),r("h5",{attrs:{id:"相同"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#相同","aria-hidden":"true"}},[a._v("#")]),a._v(" 相同")]),a._v(" "),r("ul",[r("li",[a._v("都采用性能更高的虚拟Dom")]),a._v(" "),r("li",[a._v("都支持响应式和组件化")]),a._v(" "),r("li",[a._v("都主要维护核心库，将其他功能如状态管理/路由等交给配套组件完成")])]),a._v(" "),r("h5",{attrs:{id:"差异"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#差异","aria-hidden":"true"}},[a._v("#")]),a._v(" 差异")]),a._v(" "),r("ul",[r("li",[a._v("React具有更加强大的社区生态")]),a._v(" "),r("li",[a._v("React对TS支持更高")]),a._v(" "),r("li",[a._v("Vue的组件优化更容易，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。")]),a._v(" "),r("li",[a._v("vue更接近传统的前端开发方式，模版/样式/逻辑代码结构更清晰，React主张用jsx表示一切，这赋予了React更高的灵活性，但是在某些情况下代码可读性不如Vue。")]),a._v(" "),r("li",[a._v("vue中的样式设置更加灵活，scope实现起来更加渐变")]),a._v(" "),r("li",[a._v("Vue的指令更加丰富，使用成本更低，但是增加了学习成本")]),a._v(" "),r("li",[a._v("React具备更加完善的原生渲染能力和更好的生态支持")]),a._v(" "),r("li",[a._v("两者相互借鉴，互相补充。如Mobx 实际上使用体验更接近vue，vue也可以支持jsx语法等等方面可以体现")])]),a._v(" "),r("h3",{attrs:{id:"vue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue","aria-hidden":"true"}},[a._v("#")]),a._v(" Vue")])])}),[],!1,null,null,null);t.default=v.exports}}]);
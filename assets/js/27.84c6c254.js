(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{220:function(a,t,r){"use strict";r.r(t);var e=r(0),v=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"热点速览"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#热点速览","aria-hidden":"true"}},[a._v("#")]),a._v(" 热点速览")]),a._v(" "),r("h2",{attrs:{id:"基础"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基础","aria-hidden":"true"}},[a._v("#")]),a._v(" 基础")]),a._v(" "),r("h3",{attrs:{id:"跨域"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#跨域","aria-hidden":"true"}},[a._v("#")]),a._v(" 跨域")]),a._v(" "),r("p",[a._v("JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。")]),a._v(" "),r("h4",{attrs:{id:"jsonp"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jsonp","aria-hidden":"true"}},[a._v("#")]),a._v(" JSONP")]),a._v(" "),r("p",[a._v("利用 "),r("code",[a._v("<script>")]),a._v(" 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。")]),a._v(" "),r("h5",{attrs:{id:"优点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#优点","aria-hidden":"true"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),r("ul",[r("li",[a._v("允许跨域")]),a._v(" "),r("li",[a._v("兼容性高")]),a._v(" "),r("li",[a._v("视图层与逻辑层分离")])]),a._v(" "),r("h5",{attrs:{id:"缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缺点","aria-hidden":"true"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),r("ul",[r("li",[a._v("只支持GET方式")]),a._v(" "),r("li",[a._v("失败时无法返回状态码")]),a._v(" "),r("li",[a._v("被劫持的风险高")])]),a._v(" "),r("h4",{attrs:{id:"cors"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cors","aria-hidden":"true"}},[a._v("#")]),a._v(" CORS")]),a._v(" "),r("p",[a._v("服务器允许，浏览器支持即可")]),a._v(" "),r("h4",{attrs:{id:"反向代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#反向代理","aria-hidden":"true"}},[a._v("#")]),a._v(" 反向代理")]),a._v(" "),r("p",[a._v("开发环境配置")]),a._v(" "),r("h2",{attrs:{id:"框架"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#框架","aria-hidden":"true"}},[a._v("#")]),a._v(" 框架")]),a._v(" "),r("h3",{attrs:{id:"react"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react","aria-hidden":"true"}},[a._v("#")]),a._v(" React")]),a._v(" "),r("h4",{attrs:{id:"表单控制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#表单控制","aria-hidden":"true"}},[a._v("#")]),a._v(" 表单控制")]),a._v(" "),r("h5",{attrs:{id:"受控"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#受控","aria-hidden":"true"}},[a._v("#")]),a._v(" 受控")]),a._v(" "),r("p",[a._v("react setState 控制表单元素的内容，onchange有一个处理函数")]),a._v(" "),r("h5",{attrs:{id:"非受控"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#非受控","aria-hidden":"true"}},[a._v("#")]),a._v(" 非受控")]),a._v(" "),r("p",[a._v("在 React 渲染生命周期时，表单元素上的 value 将会覆盖 DOM 节点中的值，在非受控组件中，你经常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。")]),a._v(" "),r("h4",{attrs:{id:"无状态组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#无状态组件","aria-hidden":"true"}},[a._v("#")]),a._v(" 无状态组件")]),a._v(" "),r("p",[a._v("无状态组件可以通过减少继承Component而来的生命周期函数而达到性能优化的效果。从本质上来说，无状态组件就是一个单纯的render函数，所以无状态组件的缺点也是显而易见的。因为它没有shouldComponentUpdate生命周期函数，所以每次state更新，它都会重新绘制render函数。")]),a._v(" "),r("h4",{attrs:{id:"diff"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#diff","aria-hidden":"true"}},[a._v("#")]),a._v(" diff")]),a._v(" "),r("p",[a._v("树型结构的遍历方式，react/vue 只进行同层级比较，忽略跨级操作，将复杂度由O(n^3)降低为O(n)")]),a._v(" "),r("h4",{attrs:{id:"高阶组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件","aria-hidden":"true"}},[a._v("#")]),a._v(" 高阶组件")]),a._v(" "),r("ul",[r("li",[a._v("高阶组件是参数为组件，返回值为新组件的函数，是 React 中用于复用组件逻辑的一种设计模式。")]),a._v(" "),r("li",[a._v("装饰器是高阶组件的一种实现方式")])]),a._v(" "),r("h4",{attrs:{id:"vue-对比-react"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-对比-react","aria-hidden":"true"}},[a._v("#")]),a._v(" Vue 对比 React")]),a._v(" "),r("h5",{attrs:{id:"相同"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#相同","aria-hidden":"true"}},[a._v("#")]),a._v(" 相同")]),a._v(" "),r("ul",[r("li",[a._v("虚拟dom")]),a._v(" "),r("li",[a._v("响应式和组件化")]),a._v(" "),r("li",[a._v("主要维护核心库，将其他功能如状态管理/路由等交给专业的组件完成")])]),a._v(" "),r("h5",{attrs:{id:"差异"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#差异","aria-hidden":"true"}},[a._v("#")]),a._v(" 差异")]),a._v(" "),r("ul",[r("li",[a._v("react 具有更加强大的社区生态")]),a._v(" "),r("li",[a._v("react对TS支持程度更高")]),a._v(" "),r("li",[a._v("react的组件优化成本更高 在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了 shouldComponentUpdate，并且没有上述的子树问题限制。")]),a._v(" "),r("li",[a._v("vue更接近传统的前端开发方式，模版/样式/逻辑，分的比较清晰，react将所有都用jsx表达，这赋予了react更强的灵活性，但是在某些情况下代码可读性不如vue。")]),a._v(" "),r("li",[a._v("vue中的样式设置更加灵活，scope实现起来更加简便")]),a._v(" "),r("li",[a._v("react Native 具备更加完善的原生渲染能力和更好的生态")]),a._v(" "),r("li",[a._v("两者相互借鉴，互相补充。Mobx 实际上使用体验更接近vue，vue也可以支持jsx语法等等方面可以体现")])]),a._v(" "),r("h3",{attrs:{id:"vue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue","aria-hidden":"true"}},[a._v("#")]),a._v(" Vue")])])}),[],!1,null,null,null);t.default=v.exports}}]);
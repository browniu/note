(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{204:function(v,a,_){"use strict";_.r(a);var t=_(0),e=Object(t.a)({},(function(){var v=this,a=v.$createElement,_=v._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"热点速览"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#热点速览","aria-hidden":"true"}},[v._v("#")]),v._v(" 热点速览")]),v._v(" "),_("h2",{attrs:{id:"原型链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原型链","aria-hidden":"true"}},[v._v("#")]),v._v(" 原型链")]),v._v(" "),_("ul",[_("li",[v._v("JavaScript 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。")]),v._v(" "),_("li",[v._v("定义一个a(),new a() 生成 b()，b() 的 "),_("strong",[v._v("proto")]),v._v(" 属性就是a.prototype. 当访问 b() 的一个属性, 浏览器首先查找 b() 是否有这个属性. 如果 b() 没有这个属性, 然后浏览器就会在 b() 的 "),_("strong",[v._v("proto")]),v._v(" 中查找这个属性(也就是 a.prototype). 如果 b() 的 "),_("strong",[v._v("proto")]),v._v(" 有这个属性, 那么 b() 的 "),_("strong",[v._v("proto")]),v._v(" 上的这个属性就会被使用. 否则, 浏览器就会去查找 b() 的 "),_("strong",[v._v("proto")]),v._v(" 的 "),_("strong",[v._v("proto")]),v._v(" ，看它是否有这个属性. 默认情况下, 所有函数的原型链的顶端 就是 window.Object.prototype. 如果它的上面都不存在这个属性，然后就得出这个属性是 undefined.")])]),v._v(" "),_("h2",{attrs:{id:"继承"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#继承","aria-hidden":"true"}},[v._v("#")]),v._v(" 继承")]),v._v(" "),_("p",[v._v("顾名思义，继承首先需要有父类")]),v._v(" "),_("h3",{attrs:{id:"原型链继承"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原型链继承","aria-hidden":"true"}},[v._v("#")]),v._v(" 原型链继承")]),v._v(" "),_("p",[v._v("实例B的原型等于实例A")]),v._v(" "),_("ul",[_("li",[v._v("实例C可继承的构造B、构造A、原型A的属性")]),v._v(" "),_("li",[v._v("继承单向/属性共享")])]),v._v(" "),_("h3",{attrs:{id:"构造函数继承"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#构造函数继承","aria-hidden":"true"}},[v._v("#")]),v._v(" 构造函数继承")]),v._v(" "),_("p",[v._v("用"),_("code",[v._v("call/apply")]),v._v("将父类构造函数引入子类（在子类函数中做了父类函数的自执行）")]),v._v(" "),_("ul",[_("li",[v._v("只继承父类构造函数的属性，无法继承父类原型属性")]),v._v(" "),_("li",[v._v("弥补了原型链继承的一些缺点")]),v._v(" "),_("li",[v._v("可以一对多的继承（"),_("code",[v._v("call")]),v._v("多个父类）")]),v._v(" "),_("li",[v._v("子实例可以向父实例传参")]),v._v(" "),_("li",[v._v("无法实现构造函数的复用/每个新的子实例都有父类构造函数的副本，数据臃肿")])]),v._v(" "),_("h2",{attrs:{id:"跨域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#跨域","aria-hidden":"true"}},[v._v("#")]),v._v(" 跨域")]),v._v(" "),_("p",[v._v("域的限制：JavaScript/浏览器环境出于安全方面的考虑，不允许跨域名/端口调用其他页面的对象。")]),v._v(" "),_("h3",{attrs:{id:"jsonp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jsonp","aria-hidden":"true"}},[v._v("#")]),v._v(" JSONP")]),v._v(" "),_("p",[v._v("利用 "),_("code",[v._v("<script>")]),v._v(" 元素的开放策略，可以不受域的限制从其他获取 JSON 数据。")]),v._v(" "),_("ul",[_("li",[v._v("优点 步骤简单/兼容性好")]),v._v(" "),_("li",[v._v("缺点 只支持GET方式/无法返回状态码/被劫持的风险高")])]),v._v(" "),_("h3",{attrs:{id:"cors"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cors","aria-hidden":"true"}},[v._v("#")]),v._v(" CORS")]),v._v(" "),_("p",[v._v("服务器允许，浏览器支持即可")]),v._v(" "),_("h3",{attrs:{id:"反向代理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#反向代理","aria-hidden":"true"}},[v._v("#")]),v._v(" 反向代理")]),v._v(" "),_("p",[v._v("开发环境配置，且步骤稍复杂")]),v._v(" "),_("h2",{attrs:{id:"url编码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#url编码","aria-hidden":"true"}},[v._v("#")]),v._v(" URL编码")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("encodeURI")]),v._v(" 编码整条URL（!#$&'(),;=?~）不编码")]),v._v(" "),_("li",[_("code",[v._v("encodeURIComponent")]),v._v(" 编码某一段URL （!'()*-._~）不编码")])]),v._v(" "),_("h2",{attrs:{id:"闭包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#闭包","aria-hidden":"true"}},[v._v("#")]),v._v(" 闭包")]),v._v(" "),_("p",[v._v("闭包的实质是因为函数嵌套而形成的作用域。即函数A内部有一个函数B，函数B可以访问A中的变量，B就是一个闭包。")]),v._v(" "),_("h2",{attrs:{id:"bfc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bfc","aria-hidden":"true"}},[v._v("#")]),v._v(" BFC")]),v._v(" "),_("p",[_("code",[v._v("positon:absolute/fixed")]),v._v(" / "),_("code",[v._v("display:inline-block/table")]),v._v(" / "),_("code",[v._v("float:left/right")]),v._v(" / "),_("code",[v._v("overflow!=visiblle")])]),v._v(" "),_("h2",{attrs:{id:"网页渲染的流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网页渲染的流程","aria-hidden":"true"}},[v._v("#")]),v._v(" 网页渲染的流程")]),v._v(" "),_("ul",[_("li",[v._v("输入网址")]),v._v(" "),_("li",[v._v("DNS服务器解析IP")]),v._v(" "),_("li",[v._v("建立TCP链接")]),v._v(" "),_("li",[v._v("浏览器发送HTTP请求")]),v._v(" "),_("li",[v._v("服务器返回资源")]),v._v(" "),_("li",[v._v("浏览器载入并解析资源")]),v._v(" "),_("li",[v._v("渲染DOM树/CSSOM/运行JS")])]),v._v(" "),_("h2",{attrs:{id:"纯函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#纯函数","aria-hidden":"true"}},[v._v("#")]),v._v(" 纯函数")]),v._v(" "),_("p",[v._v("如果函数的调用参数完全相同，则永远返回相同的结果。它不依赖程序执行期间的函数外部的任何状态，不产生任何可观察的副作用（状态交互），便于测试和重构。")]),v._v(" "),_("h2",{attrs:{id:"tcp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp","aria-hidden":"true"}},[v._v("#")]),v._v(" TCP")]),v._v(" "),_("h3",{attrs:{id:"三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手","aria-hidden":"true"}},[v._v("#")]),v._v(" 三次握手")]),v._v(" "),_("p",[v._v("客户端与服务器建立建立TCP链接时的通信协议")]),v._v(" "),_("ul",[_("li",[v._v("客户端发送"),_("code",[v._v("SYN")]),v._v("请求（能听到我说话吗？）")]),v._v(" "),_("li",[v._v("服务器收到"),_("code",[v._v("SYN")]),v._v("请求包，确认后发出自身的"),_("code",[v._v("SYN+ACK")]),v._v("请求包（听到了，你能听到我说话吗？）")]),v._v(" "),_("li",[v._v("客户端收到"),_("code",[v._v("SYN+ACK")]),v._v("请求包，确认后发出"),_("code",[v._v("ACK")]),v._v("包，进入链接状态（好的，那我们开始聊天吧）")])]),v._v(" "),_("h3",{attrs:{id:"四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手","aria-hidden":"true"}},[v._v("#")]),v._v(" 四次挥手")]),v._v(" "),_("p",[v._v("客户端与服务器断开TCP链接时的操作")]),v._v(" "),_("ul",[_("li",[v._v("客户端发送一个请求断开的包（我挂了）")]),v._v(" "),_("li",[v._v("服务端返回一个同意断开的包（好的）")]),v._v(" "),_("li",[v._v("服务端发送一个请求断开的包（我也挂了）")]),v._v(" "),_("li",[v._v("客户端发送一个确认断开的包（好的）")])]),v._v(" "),_("h2",{attrs:{id:"深拷贝"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝","aria-hidden":"true"}},[v._v("#")]),v._v(" 深拷贝")]),v._v(" "),_("p",[v._v("深拷贝是指源对象和拷贝对象相互独立，其中任何一个发生变化都不会对对方产生影响。深浅拷贝最根本的区别就是是否真正获取到一个对象的复制实体，而不是引用。深拷贝在内存中新建了复制体的存储，而浅拷贝只是引用了源头的内存地址。")]),v._v(" "),_("ul",[_("li",[v._v("使用JSON "),_("code",[v._v("b=JSON.parse(JSON.sringify(a))")])]),v._v(" "),_("li",[v._v("递归遍历属性")])]),v._v(" "),_("h2",{attrs:{id:"数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据类型","aria-hidden":"true"}},[v._v("#")]),v._v(" 数据类型")]),v._v(" "),_("ul",[_("li",[v._v("基本："),_("code",[v._v("undefined")]),v._v(" "),_("code",[v._v("null")]),v._v(" "),_("code",[v._v("string")]),v._v(" "),_("code",[v._v("number")]),v._v(" "),_("code",[v._v("boolean")])]),v._v(" "),_("li",[v._v("引用："),_("code",[v._v("object")]),v._v(" "),_("code",[v._v("array")]),v._v(" "),_("code",[v._v("function")])])]),v._v(" "),_("h2",{attrs:{id:"diff"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#diff","aria-hidden":"true"}},[v._v("#")]),v._v(" diff")]),v._v(" "),_("p",[v._v("比较文本差异的算法")]),v._v(" "),_("ul",[_("li",[v._v("比较两个树形数据结构的差异时，传统diff算法是循环递归每一个节点，复杂度达到O(n^3)")]),v._v(" "),_("li",[v._v("React/Vue 只进行同层级比较，忽略跨级操作，将复杂度降低为O(n)。开发过程中列表渲染时设置的key值就是分配给同一层级的一组子节点，作为唯一id进行区分")])]),v._v(" "),_("h2",{attrs:{id:"前端框架比较"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端框架比较","aria-hidden":"true"}},[v._v("#")]),v._v(" 前端框架比较")]),v._v(" "),_("h3",{attrs:{id:"共相同"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#共相同","aria-hidden":"true"}},[v._v("#")]),v._v(" 共相同")]),v._v(" "),_("ul",[_("li",[v._v("都采用性能更高的虚拟Dom")]),v._v(" "),_("li",[v._v("都支持响应式和组件化")]),v._v(" "),_("li",[v._v("都主要维护核心库，将其他功能如状态管理/路由等交给配套组件完成")])]),v._v(" "),_("h3",{attrs:{id:"差异点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#差异点","aria-hidden":"true"}},[v._v("#")]),v._v(" 差异点")]),v._v(" "),_("ul",[_("li",[v._v("数据流 React是MVC单向数据流，Vue是MVVM双向数据流")]),v._v(" "),_("li",[v._v("React兼容性更好，支持IE8")]),v._v(" "),_("li",[v._v("React具有更加强大的社区生态")]),v._v(" "),_("li",[v._v("React对TS支持更高")]),v._v(" "),_("li",[v._v("Vue的组件优化更容易，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。")]),v._v(" "),_("li",[v._v("vue更接近传统的前端开发方式，模版/样式/逻辑代码结构更清晰，React主张用jsx表示一切，这赋予了React更高的灵活性，但是在某些情况下代码可读性不如Vue。")]),v._v(" "),_("li",[v._v("vue中的样式设置更加灵活，scope实现起来更加简便")]),v._v(" "),_("li",[v._v("Vue的指令更加丰富，使用成本更低，但是增加了学习成本")]),v._v(" "),_("li",[v._v("React具备更加完善的原生渲染能力和更好的生态支持")]),v._v(" "),_("li",[v._v("两者相互借鉴，互相补充。如Mobx 实际上使用体验更接近vue，vue也可以支持jsx语法等等方面可以体现")])]),v._v(" "),_("h2",{attrs:{id:"常用状态码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常用状态码","aria-hidden":"true"}},[v._v("#")]),v._v(" 常用状态码")]),v._v(" "),_("ul",[_("li",[v._v("200 请求成功")]),v._v(" "),_("li",[v._v("300 重定向，当客户端的请求引起了资源URI的变化时发送此状态码")]),v._v(" "),_("li",[v._v("404 请求资源不存在")]),v._v(" "),_("li",[v._v("500 服务器内部错误")])]),v._v(" "),_("h2",{attrs:{id:"mvvm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mvvm","aria-hidden":"true"}},[v._v("#")]),v._v(" MVVM")]),v._v(" "),_("p",[v._v("MVVM包含三个部分Model、View、ViewModel。")]),v._v(" "),_("ul",[_("li",[v._v("Model代表数据模型，定义数据和业务逻辑")]),v._v(" "),_("li",[v._v("View代表视图，负责数据UI展示")]),v._v(" "),_("li",[v._v("ViewModel作为中间层负责监听Model中的数据改变然后控制View的更新")])]),v._v(" "),_("h2",{attrs:{id:"优化首屏加载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优化首屏加载","aria-hidden":"true"}},[v._v("#")]),v._v(" 优化首屏加载")]),v._v(" "),_("ul",[_("li",[v._v("将公用的JS库通过"),_("script")])])])}),[],!1,null,null,null);a.default=e.exports}}]);